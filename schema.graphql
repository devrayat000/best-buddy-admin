# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type User {
  id: ID!
  name: String!
  email: String!
  password: PasswordState
  notices(where: NoticeWhereInput! = {}, orderBy: [NoticeOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: NoticeWhereUniqueInput): [Notice!]
  noticesCount(where: NoticeWhereInput! = {}): Int
  classTests(where: ClassTestWhereInput! = {}, orderBy: [ClassTestOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ClassTestWhereUniqueInput): [ClassTest!]
  classTestsCount(where: ClassTestWhereInput! = {}): Int
  tokens(where: FcmTokenWhereInput! = {}, orderBy: [FcmTokenOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: FcmTokenWhereUniqueInput): [FcmToken!]
  tokensCount(where: FcmTokenWhereInput! = {}): Int
  role: UserRoleType
  createdAt: DateTime
  updatedAt: DateTime
}

type PasswordState {
  isSet: Boolean!
}

enum UserRoleType {
  admin
  CR
  user
}

scalar DateTime @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input UserWhereUniqueInput {
  id: ID
  email: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  name: StringFilter
  email: StringFilter
  notices: NoticeManyRelationFilter
  classTests: ClassTestManyRelationFilter
  tokens: FcmTokenManyRelationFilter
  role: UserRoleTypeNullableFilter
  createdAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input NoticeManyRelationFilter {
  every: NoticeWhereInput
  some: NoticeWhereInput
  none: NoticeWhereInput
}

input ClassTestManyRelationFilter {
  every: ClassTestWhereInput
  some: ClassTestWhereInput
  none: ClassTestWhereInput
}

input FcmTokenManyRelationFilter {
  every: FcmTokenWhereInput
  some: FcmTokenWhereInput
  none: FcmTokenWhereInput
}

input UserRoleTypeNullableFilter {
  equals: UserRoleType
  in: [UserRoleType!]
  notIn: [UserRoleType!]
  not: UserRoleTypeNullableFilter
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input UserOrderByInput {
  id: OrderDirection
  name: OrderDirection
  email: OrderDirection
  role: OrderDirection
  createdAt: OrderDirection
  updatedAt: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input UserUpdateInput {
  password: String!
  notices: NoticeRelateToManyForUpdateInput
  classTests: ClassTestRelateToManyForUpdateInput
  tokens: FcmTokenRelateToManyForUpdateInput
  role: UserRoleType
  createdAt: DateTime
  updatedAt: DateTime
}

input NoticeRelateToManyForUpdateInput {
  disconnect: [NoticeWhereUniqueInput!]
  set: [NoticeWhereUniqueInput!]
  create: [NoticeCreateInput!]
  connect: [NoticeWhereUniqueInput!]
}

input ClassTestRelateToManyForUpdateInput {
  disconnect: [ClassTestWhereUniqueInput!]
  set: [ClassTestWhereUniqueInput!]
  create: [ClassTestCreateInput!]
  connect: [ClassTestWhereUniqueInput!]
}

input FcmTokenRelateToManyForUpdateInput {
  disconnect: [FcmTokenWhereUniqueInput!]
  set: [FcmTokenWhereUniqueInput!]
  create: [FcmTokenCreateInput!]
  connect: [FcmTokenWhereUniqueInput!]
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  name: String! = ""
  email: String! = ""
  password: String!
  notices: NoticeRelateToManyForCreateInput
  classTests: ClassTestRelateToManyForCreateInput
  tokens: FcmTokenRelateToManyForCreateInput
  role: UserRoleType
  createdAt: DateTime
  updatedAt: DateTime
}

input NoticeRelateToManyForCreateInput {
  create: [NoticeCreateInput!]
  connect: [NoticeWhereUniqueInput!]
}

input ClassTestRelateToManyForCreateInput {
  create: [ClassTestCreateInput!]
  connect: [ClassTestWhereUniqueInput!]
}

input FcmTokenRelateToManyForCreateInput {
  create: [FcmTokenCreateInput!]
  connect: [FcmTokenWhereUniqueInput!]
}

type FcmToken {
  id: ID!
  token: String
  deviceType: FcmTokenDeviceTypeType
  createdAt: DateTime
  updatedAt: DateTime
  user: User
}

enum FcmTokenDeviceTypeType {
  ios
  android
}

input FcmTokenWhereUniqueInput {
  id: ID
  token: String
}

input FcmTokenWhereInput {
  AND: [FcmTokenWhereInput!]
  OR: [FcmTokenWhereInput!]
  NOT: [FcmTokenWhereInput!]
  id: IDFilter
  token: StringFilter
  deviceType: FcmTokenDeviceTypeTypeNullableFilter
  createdAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
  user: UserWhereInput
}

input FcmTokenDeviceTypeTypeNullableFilter {
  equals: FcmTokenDeviceTypeType
  in: [FcmTokenDeviceTypeType!]
  notIn: [FcmTokenDeviceTypeType!]
  not: FcmTokenDeviceTypeTypeNullableFilter
}

input FcmTokenOrderByInput {
  id: OrderDirection
  token: OrderDirection
  deviceType: OrderDirection
  createdAt: OrderDirection
  updatedAt: OrderDirection
}

input FcmTokenUpdateInput {
  token: String
  deviceType: FcmTokenDeviceTypeType
  createdAt: DateTime
  updatedAt: DateTime
  user: UserRelateToOneForUpdateInput
}

input UserRelateToOneForUpdateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
}

input FcmTokenUpdateArgs {
  where: FcmTokenWhereUniqueInput!
  data: FcmTokenUpdateInput!
}

input FcmTokenCreateInput {
  token: String
  deviceType: FcmTokenDeviceTypeType
  createdAt: DateTime
  updatedAt: DateTime
  user: UserRelateToOneForCreateInput
}

input UserRelateToOneForCreateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type Notice {
  id: ID!
  title: String
  content: Notice_content_Document
  contentSummary(length: Int): String!
  createdBy: User
  createdAt: DateTime
  updatedAt: DateTime
}

type Notice_content_Document {
  document(hydrateRelationships: Boolean! = false): JSON!
}

input NoticeWhereUniqueInput {
  id: ID
}

input NoticeWhereInput {
  AND: [NoticeWhereInput!]
  OR: [NoticeWhereInput!]
  NOT: [NoticeWhereInput!]
  id: IDFilter
  title: StringFilter
  createdBy: UserWhereInput
  createdAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input NoticeOrderByInput {
  id: OrderDirection
  title: OrderDirection
  createdAt: OrderDirection
  updatedAt: OrderDirection
}

input NoticeUpdateInput {
  title: String
  content: JSON
  createdBy: UserRelateToOneForUpdateInput
  createdAt: DateTime
  updatedAt: DateTime
}

input NoticeUpdateArgs {
  where: NoticeWhereUniqueInput!
  data: NoticeUpdateInput!
}

input NoticeCreateInput {
  title: String
  content: JSON
  createdBy: UserRelateToOneForCreateInput
  createdAt: DateTime
  updatedAt: DateTime
}

type ClassTest {
  id: ID!
  title: String!
  content: ClassTest_content_Document!
  contentSummary(length: Int): String!
  datetime: DateTime!
  createdBy: User
  createdAt: DateTime
  updatedAt: DateTime
}

type ClassTest_content_Document {
  document(hydrateRelationships: Boolean! = false): JSON!
}

input ClassTestWhereUniqueInput {
  id: ID
}

input ClassTestWhereInput {
  AND: [ClassTestWhereInput!]
  OR: [ClassTestWhereInput!]
  NOT: [ClassTestWhereInput!]
  id: IDFilter
  title: StringFilter
  datetime: DateTimeFilter
  createdBy: UserWhereInput
  createdAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input DateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeFilter
}

input ClassTestOrderByInput {
  id: OrderDirection
  title: OrderDirection
  datetime: OrderDirection
  createdAt: OrderDirection
  updatedAt: OrderDirection
}

input ClassTestUpdateInput {
  title: String
  content: JSON
  datetime: DateTime
  createdBy: UserRelateToOneForUpdateInput
  createdAt: DateTime
  updatedAt: DateTime
}

input ClassTestUpdateArgs {
  where: ClassTestWhereUniqueInput!
  data: ClassTestUpdateInput!
}

input ClassTestCreateInput {
  title: String! = ""
  content: JSON!
  datetime: DateTime!
  createdBy: UserRelateToOneForCreateInput
  createdAt: DateTime
  updatedAt: DateTime
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  createFcmToken(data: FcmTokenCreateInput!): FcmToken
  createFcmTokens(data: [FcmTokenCreateInput!]!): [FcmToken]
  updateFcmToken(where: FcmTokenWhereUniqueInput!, data: FcmTokenUpdateInput!): FcmToken
  updateFcmTokens(data: [FcmTokenUpdateArgs!]!): [FcmToken]
  deleteFcmToken(where: FcmTokenWhereUniqueInput!): FcmToken
  deleteFcmTokens(where: [FcmTokenWhereUniqueInput!]!): [FcmToken]
  createNotice(data: NoticeCreateInput!): Notice
  createNotices(data: [NoticeCreateInput!]!): [Notice]
  updateNotice(where: NoticeWhereUniqueInput!, data: NoticeUpdateInput!): Notice
  updateNotices(data: [NoticeUpdateArgs!]!): [Notice]
  deleteNotice(where: NoticeWhereUniqueInput!): Notice
  deleteNotices(where: [NoticeWhereUniqueInput!]!): [Notice]
  createClassTest(data: ClassTestCreateInput!): ClassTest
  createClassTests(data: [ClassTestCreateInput!]!): [ClassTest]
  updateClassTest(where: ClassTestWhereUniqueInput!, data: ClassTestUpdateInput!): ClassTest
  updateClassTests(data: [ClassTestUpdateArgs!]!): [ClassTest]
  deleteClassTest(where: ClassTestWhereUniqueInput!): ClassTest
  deleteClassTests(where: [ClassTestWhereUniqueInput!]!): [ClassTest]
  endSession: Boolean!
  authenticateUserWithPassword(email: String!, password: String!): UserAuthenticationWithPasswordResult
  createInitialUser(data: CreateInitialUserInput!): UserAuthenticationWithPasswordSuccess!
  refreshSession: String!
  updateProfile(data: UserUpdateInput!): User
  uploadFcmToken(data: FcmTokenUploadInput!): FcmToken
}

input FcmTokenUploadInput {
  token: String!
  deviceType: DeviceType = android
}

enum DeviceType {
  ios
  android
}

union UserAuthenticationWithPasswordResult = UserAuthenticationWithPasswordSuccess | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  message: String!
}

input CreateInitialUserInput {
  name: String! = ""
  email: String! = ""
  password: String!
}

type Query {
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  usersCount(where: UserWhereInput! = {}): Int
  fcmToken(where: FcmTokenWhereUniqueInput!): FcmToken
  fcmTokens(where: FcmTokenWhereInput! = {}, orderBy: [FcmTokenOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: FcmTokenWhereUniqueInput): [FcmToken!]
  fcmTokensCount(where: FcmTokenWhereInput! = {}): Int
  notice(where: NoticeWhereUniqueInput!): Notice
  notices(where: NoticeWhereInput! = {}, orderBy: [NoticeOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: NoticeWhereUniqueInput): [Notice!]
  noticesCount(where: NoticeWhereInput! = {}): Int
  classTest(where: ClassTestWhereUniqueInput!): ClassTest
  classTests(where: ClassTestWhereInput! = {}, orderBy: [ClassTestOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ClassTestWhereUniqueInput): [ClassTest!]
  classTestsCount(where: ClassTestWhereInput! = {}): Int
  keystone: KeystoneMeta!
  authenticatedItem: AuthenticatedItem
}

union AuthenticatedItem = User

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  groups: [KeystoneAdminUIFieldGroupMeta!]!
  graphql: KeystoneAdminUIGraphQL!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
  isSingleton: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  description: String
  isOrderable: Boolean!
  isFilterable: Boolean!
  isNonNull: [KeystoneAdminUIFieldMetaIsNonNull!]
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

enum KeystoneAdminUIFieldMetaIsNonNull {
  read
  create
  update
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
  fieldPosition: KeystoneAdminUIFieldMetaItemViewFieldPosition
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

enum KeystoneAdminUIFieldMetaItemViewFieldPosition {
  form
  sidebar
}

type KeystoneAdminUIFieldGroupMeta {
  label: String!
  description: String
  fields: [KeystoneAdminUIFieldMeta!]!
}

type KeystoneAdminUIGraphQL {
  names: KeystoneAdminUIGraphQLNames!
}

type KeystoneAdminUIGraphQLNames {
  outputTypeName: String!
  whereInputName: String!
  whereUniqueInputName: String!
  createInputName: String!
  createMutationName: String!
  createManyMutationName: String!
  relateToOneForCreateInputName: String!
  relateToManyForCreateInputName: String!
  itemQueryName: String!
  listOrderName: String!
  listQueryCountName: String!
  listQueryName: String!
  updateInputName: String!
  updateMutationName: String!
  updateManyInputName: String!
  updateManyMutationName: String!
  relateToOneForUpdateInputName: String!
  relateToManyForUpdateInputName: String!
  deleteMutationName: String!
  deleteManyMutationName: String!
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
